# -*- coding: utf-8 -*-
"""chess_project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15PEpeWyCRX3ZB067LJEfQrFe4sPzzeZP
"""

import os
import math
import numpy as np
import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt
import sklearn as skl
import statsmodels.api as sm

"""##**A) Data-set presentation**

This data-set groups data from more than 20,000 games collected from a selection of users on the site Lichess.org. This set contains:
*  Game ID;
*  Rated (Boolean value);
*  Start Time;
*  End Time;
*  Number of Turns;
*  Game Status;
*  Winner;
*  Time Increment;
*  White Player ID;
*  White Player Rating;
*  Black Player ID;
*  Black Player Rating;
*  All Moves in Standard Chess Notation;
*  Opening Eco (Standardised Code for any given opening, list here);
*  Opening Name;
*  Opening Ply (Number of moves in the opening phase);
"""

chess_df = pd.read_csv('/content/chess.csv')

chess_df.head(3)

chess_df.info()

chess_df.describe()

"""***DATA HANDLING***

First it's generated a backup of the original data set:
"""

chess_df_backup = chess_df.copy()

"""Then all the columns that will not be used are dropped and two new columns are added:
* "white_win" : equals 1 if winner it's white player, 0 otherwise;
* "black_win" : equals 1 if winner it's black player, 0 otherwise.
"""

chess_df.drop(['moves', 'white_id', 'black_id', 'id', 'created_at', 'last_move_at', 'rated'], axis=1, inplace = True )

chess_df['white_win'] = ( chess_df['winner'] == 'white' ) * 1

chess_df['black_win'] = ( chess_df['winner'] == 'black' ) * 1

chess_df.head(3)

"""***GENERAL CORRELATION***

Now it' ll be plotted a correlation graphs of the numerical variables in the data set.
"""

chess_corr = chess_df.corr()

plt.figure(figsize=(8, 6))
sb.heatmap(chess_corr, annot = True, )

plt.show()

"""As a first impression, the only parameters that seems to have a little correlation are:

* **white_rating and black_rating:** positive correlation, this is because matchmaking software matches opponents with similar ratings.
* **white_win and black_win:** negative correlation, obviously because if one player win, then the other loose. The correlation is not -1 because there can be some draws.

## **B) Which are the most common matches outcomes? What are the most played type of matches?**

***MOST COMMON MATCHES OUTCOMES***
"""

endgame_reason_df = chess_df['victory_status'].value_counts()

plt.figure(figsize=(6,6))
plt.pie(endgame_reason_df, labels = endgame_reason_df.index, autopct = '%i%%')
plt.title('DISTRIBUTION OF ENDGAME REASON ')

plt.show()

"""It's easy to see that the most endgame reason is "resign" followed by "checkmate". "Draws" and "out of time" are widely less frequent.

***MOST PLAYED TYPE OF MATCHES***

First, it's generated a boolean mask to exclude the least played match types ( <  2% of the total 20.000+ matches)
"""

most_played_mask = chess_df['increment_code'].value_counts() > chess_df['increment_code'].value_counts().sum() * 0.02

"""Then it's created a data frame of the most played type of matches so it can be plotted in a pie-chart. This DF groups match types played less than 2% of the total at the 'other' index."""

most_played_df = chess_df['increment_code'].value_counts()[most_played_mask]

other = chess_df['increment_code'].value_counts().sum()- most_played_df.sum()
other_dict={'other':other}
other_series = pd.Series(other_dict)

all_type_df = most_played_df.append(other_series, ignore_index= False)

plt.figure(figsize = (7,7))
explode = (0.04, 0, 0, 0, 0, 0, 0, 0, 0, 0)
plt.pie(all_type_df, labels = all_type_df.index, explode = explode, autopct = '%i%%')
plt.title('Most played type of matches', fontdict={'fontsize':'20'})

plt.show()

"""It's higlited that the most frequently played match types are the 10+0. All other types are definitely less played.

## **C) Is there some correlation between starting with white pieces and the outcome of the match?**

This question can be answered plotting a bar-chart of the distribution of matches outcomes.
"""

winner_df = chess_df['winner'].value_counts()
winner_df

plt.figure(figsize=(6,4))
plt.bar(winner_df.index, winner_df, color = ('skyblue', 'pink', 'red'), edgecolor = 'black')
plt.title('Distribution of matches outcomes')

plt.show()

"""As we can see, white players have few more wins than black ones but the difference is very small:"""

difference = chess_df['winner'].value_counts()['white']-chess_df['winner'].value_counts()['black']
difference

difference_pct = int((chess_df['winner'].value_counts('pct')['white']-chess_df['winner'].value_counts('pct')['black'])*100)
print(difference_pct, '%')

"""only 894 matches (4%).

## **C.1) How the situation changes when matches became longer in terms of number of turns?**

Now it will be analyzed if the difference get bigger o smaller when matches have higher and lower number of turns. Matches with 79 (75% of turns distribution) or more  turns will be considered many-turns matches and matches with 37 (25% of turns distribution) or less turns will be considered few-turns matches. The first step is to generate the two DF.
"""

many_turns_matches_mask = chess_df ['turns'] >= 79
many_turns_matches_df = chess_df[many_turns_matches_mask]
mtm_winner_df = many_turns_matches_df['winner'].value_counts()

few_turns_matches_mask = chess_df ['turns'] <= 37
few_turns_matches_df = chess_df[few_turns_matches_mask]
ftm_winner_df = few_turns_matches_df['winner'].value_counts()

"""***MANY-TURNS MATCHES***"""

mtm_winner_df

difference =mtm_winner_df['white']-mtm_winner_df['black']
difference

difference_pct = round((many_turns_matches_df['winner'].value_counts('pct')['white']-many_turns_matches_df['winner'].value_counts('pct')['black'])*100)
print(difference_pct, '%')

"""It can be noticed that the percentage of white winning in many-turns matches, is decreased compared to the original data set matches.

***FEW-TURNS MATCHES***
"""

difference = ftm_winner_df['white']-ftm_winner_df['black']
difference

difference_pct = round((few_turns_matches_df['winner'].value_counts('pct')['white']-few_turns_matches_df['winner'].value_counts('pct')['black'])*100)
print(difference_pct, '%')

"""By contrast, the percentage of white winning in the few-turns matches DF is increased.

***PLOTS***
"""

fig_1 = plt.figure(figsize=(10,15))
ax_1 = fig_1.add_subplot(3, 2, 1)
ax_2 = fig_1.add_subplot(3, 2, 2)
ax_3 = fig_1.add_subplot(3, 2, 3)
ax_4 = fig_1.add_subplot(3, 2, 4)
ax_5 = fig_1.add_subplot(3, 2, 5)
ax_6 = fig_1.add_subplot(3, 2, 6)

ax_1.bar(winner_df.index, winner_df, color = ('skyblue', 'pink', 'red'), edgecolor = 'black')
ax_1.set_title('Distribution of matches outcomes')

ax_2.pie(winner_df, labels = winner_df.index, autopct = '%.1f%%', colors = ('skyblue', 'pink', 'red'))
ax_2.set_title('Pie-chart of matches outcomes')

ax_3.bar(ftm_winner_df.index, ftm_winner_df, color = ('skyblue', 'pink', 'red'), edgecolor = 'black')
ax_3.set_title('Distribution of few-turns matches outcomes')

ax_4.pie(ftm_winner_df, labels = ftm_winner_df.index, autopct = '%.1f%%', colors = ('skyblue', 'pink', 'red'))
ax_4.set_title('Pie-chart of few-turns matches outcomes')

ax_5.bar(mtm_winner_df.index, mtm_winner_df, color = ('skyblue', 'pink', 'red'), edgecolor = 'black')
ax_5.set_title('Distribution of many-turns matches outcomes')

ax_6.pie(mtm_winner_df, labels = mtm_winner_df.index, autopct = '%.1f%%', colors = ('skyblue', 'pink', 'red'))
ax_6.set_title('Pie-chart of many-turns matches outcomes')

plt.show()

"""From this figure, can also be noticed that the percentage of draws increas in many-turns matches.

## **C.2) Regression model for C.1  question**
"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix

"""Two new DFs are generated: these ones collect the victory percentage of the black and white player depending on the value of variable "turns"."""

white_win_mask = chess_df['winner'] == 'white'
white_win_df = chess_df[white_win_mask]
black_win_mask = chess_df['winner'] == 'black'
black_win_df = chess_df[black_win_mask]

ww_turns_pct = white_win_df['turns'].value_counts() / chess_df['turns'].value_counts()
bw_turns_pct = black_win_df['turns'].value_counts() / chess_df['turns'].value_counts()

"""These two DFs are plotted:

*   Blue pallets reports white players win
*   Pink pallets reports black players win



"""

plt.figure(figsize = (8,4))
plt.scatter(ww_turns_pct.index, ww_turns_pct, c = 'skyblue')
plt.title('Distribution of white winning percentage related to number of turns')

plt.show()

plt.figure(figsize = (8,4))
plt.scatter(bw_turns_pct.index, bw_turns_pct, c = 'pink')
plt.title('Distribution of black winning percentage related to number of turns')

plt.show()

plt.figure(figsize = (8,4))
plt.scatter(ww_turns_pct.index, ww_turns_pct, c = 'skyblue')
plt.scatter(bw_turns_pct.index, bw_turns_pct, c = 'pink')
plt.title('Combination of the two previous graphs ')

plt.show()

"""These graphs show that there is no definite pattern, but it can be noticed that there are many values at the extremes, this is because white usually win in an odd-numbered round, while black in an even-numbered round.

For this reason is much interesting studing the distribution of draws:

Now will be introduced two new columns in the data set:

*   "draws": boolean value that is worth 1 if the match is a tie and 0 if it is not;
*   "rating_diff" : indicates the rating difference between the two players in absolute value;  

It's also generated a new DF, draw_turns_pct, that collects the percentage of draws per number of turns
"""

draw_mask = chess_df['winner'] == 'draw'
draw_df = chess_df[draw_mask]

chess_df ['draw'] = draw_mask * 1
chess_df ['rating_diff'] = abs (chess_df['white_rating'] - chess_df ['black_rating'])

draw_turns_pct = draw_df['turns'].value_counts() / chess_df['turns'].value_counts()

plt.figure(figsize = (10,4))
plt.scatter(draw_turns_pct.index, draw_turns_pct, c = 'red')
plt.title('Distribution of draws percentage related to number of turns ')
plt.show()

"""It seems to be an exponential distribution:
yp = f(xp) is an exponential function defined as follows:
"""

kp = np.log(2) / 250
xp = np.linspace(0, 250, 10000)
yp = 0.2 * np.exp(0.0075 * xp) - 0.2

plt.figure(figsize = (10,4))
plt.scatter(draw_turns_pct.index, draw_turns_pct, c = 'red')
plt.plot(xp, yp)
plt.xlim(0, 260)
plt.ylim(-0.1, 1.1)
plt.title('Distribution of draws percentage related to number of turns ')

plt.show()

"""Now it's generated a logit model that study the influention of number of turns and rating difference between the two players on the probability of a draw."""

variables = ['turns', 'rating_diff']
x = chess_df[variables]
y = chess_df['draw']

x_train_chess_df, x_test_chess_df, y_train_chess_df, y_test_chess_df = train_test_split(x, y, test_size = 0.5, random_state = 5)

model = sm.MNLogit(y_train_chess_df, sm.add_constant(x_train_chess_df))
result = model.fit()
stats = result.summary()
print(stats)

"""## **D) What are the best opening moves for white player? And for black one?**

***DATA-FRAMES GENERATION***

Two new DataFrames are generated: the first goups the most common openings when white player wins and the second is the same but for matches in wich black player is the winner (only openings that have been used at least 2% of the considered matches are analyzed).
"""

common_openings_white_win_mask = white_win_df['opening_eco'].value_counts('pct') > 0.02
co_white_win_df = white_win_df['opening_eco'].value_counts()[common_openings_white_win_mask]

co_white_win_pct_df = co_white_win_df / co_white_win_df.sum()

co_white_win_pct_df

common_openings_black_win_mask = black_win_df['opening_eco'].value_counts('pct') > 0.02
co_black_win_df = black_win_df['opening_eco'].value_counts()[common_openings_black_win_mask]
co_black_win_pct_df = co_black_win_df / co_black_win_df.sum()

co_black_win_pct_df

"""Now, in order to compare white and black best opening moves, it's generated a new DF as follows:"""

delta = co_black_win_df - co_white_win_df
delta.fillna(co_black_win_df, inplace = True)
delta.fillna(co_white_win_df, inplace = True)

delta_pct = delta / (co_black_win_df + co_white_win_df)
delta_pct.fillna(delta / co_black_win_df, inplace = True)
delta_pct.fillna(delta / co_white_win_df, inplace = True)
delta_pct

"""***PLOTS***"""

plt.figure(figsize = (10,4))
plt.bar(co_white_win_pct_df.index, co_white_win_pct_df, color = ('skyblue'), edgecolor = 'black')
plt.title('Most common openings when \nWHITE player wins', fontdict={'fontsize':'20'})

plt.show()

"""This bar-chart shows that the distribution of opening moves is quite regular: the frequencies of C00, A00, C41, B00, B01, D00 and A40 are very close."""

plt.figure(figsize = (10,4))
plt.bar(co_black_win_pct_df.index, co_black_win_pct_df, color = ('pink'), edgecolor = 'black')
plt.title('Most common openings when \nBLACK player wins', fontdict={'fontsize':'20'})

plt.show()

"""In this case, howevere, the distribution has a peak in A00, but then it's quite regular."""

plt.figure(figsize = (10,4))
plt.bar(delta_pct.index, delta_pct, color = ('lightgreen'), edgecolor = 'black')
plt.title('Delta of best opening moves', fontdict={'fontsize':'20'})

plt.show()

"""This bar-chart must be read as follows:


*   positive values refear to good openings for black player;
*   negtive values refear to good openings for white player.

(Example: B00: -0,25 indicates that in a match that has B00 as opening, white has a 25% greater chance of winning than black.)

**NOTE:** C40 can be considered the best opening move for black player with an efficency of almost 100%. This happens because C40 is rarely linked to a victory by the white player, so it recived a FALSE boolean value in the "common_opening_white_win_mask".

From this DF will be removed all the values under 10%: these openeing moves are considered only because they are quite frequently used but they are not linked to a significant difference of winning probability.

"""

significant_mask = abs(delta_pct) > 0.1
significant_delta = delta_pct[significant_mask]
significant_delta

plt.figure(figsize = (10,4))
plt.bar(significant_delta.index, significant_delta, color = ('green'), edgecolor = 'black')
plt.title('Delta of significant best opening moves', fontdict={'fontsize':'20'})

plt.show()

"""This graph highlites that:

*   **C40** is the best opening move for black player, but also **A00** and **B00** are good choice;
*   **A40**, **B00** and **C41** are the best opeing options for white player.


"""